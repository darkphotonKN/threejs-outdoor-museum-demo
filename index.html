<!DOCTYPE html>
<html lang="zh-TW">

<head>
	<meta charset="UTF-8" />
	<title>demo</title>
	<link type="text/css" rel="stylesheet" href="main.css" />
</head>

<body>
	<div id="info">three.js - museum-demo.</div>
	<div id="blocker">
		<div id="instructions">
			<span style="font-size: 40px">點擊開始</span>
			<br />
			<br />
			(W, A, S, D = 移動, 滑鼠移動 = 移動視角, ESC = 結束)
		</div>
	</div>

	<script type="module">
		import * as THREE from "../build/three.module.js";

		import { GUI } from "./jsm/libs/dat.gui.module.js";
		import { OrbitControls } from "./jsm/controls/OrbitControls.js";
		import { PointerLockControls } from "./jsm/controls/PointerLockControls.js";
		import { RectAreaLightHelper } from "./jsm/helpers/RectAreaLightHelper.js";
		import { RectAreaLightUniformsLib } from "./jsm/lights/RectAreaLightUniformsLib.js";
		import { GLTFLoader } from './jsm/loaders/GLTFLoader.js';
		import { OBJLoader } from './jsm/loaders/OBJLoader.js';
		import { MTLLoader } from './jsm/loaders/MTLLoader.js';
		import { ColladaLoader } from './jsm/loaders/ColladaLoader.js';
		import Stats from "./jsm/libs/stats.module.js";

		let renderer, 
		camera, 
		scene, 
		gui, 
		light, 
		stats, 
		controls,
		cubeCamera;

		let groundPlane, wallMat, wallMatPaintingMat1, wallMatPaintingMat2;
		let geometry;
		let cube;

		// camera
		const VIEW_ANGLE = 45;
		const ASPECT = window.innerWidth / window.innerHeight;
		const NEAR = 1;
		const FAR = 1000;

		//move
		var moveForward = false;
		var moveBackward = false;
		var moveLeft = false;
		var moveRight = false;
		var raycaster;
		var objects = [];
		var prevTime = performance.now();
		const velocity = new THREE.Vector3();

		draw();

		function initRender() {
			renderer = new THREE.WebGLRenderer({ antialias: true });
			renderer.setPixelRatio(window.devicePixelRatio);
			renderer.setSize(window.innerWidth, window.innerHeight); // 場景大小
			renderer.setClearColor(0x000000, 1.0); // 預設背景顏色
			renderer.shadowMap.enable = true // 陰影效果

			document.body.appendChild(renderer.domElement);
		}

		function initCamera() {
			camera = new THREE.PerspectiveCamera(VIEW_ANGLE, ASPECT, NEAR, FAR);
			camera.position.set(200, 0, 0);
			camera.lookAt(scene.position);
			// camera.lookAt(new THREE.Vector3(-10, 10, 10));
		}

		function initScene() {
			scene = new THREE.Scene();
		}

		function initGUI(){
			// gui controls
			const gui = new GUI();
		}


		function initLight() {
			scene.add(new THREE.AmbientLight(0x444444));
			// light = new THREE.DirectionalLight(0xffffff);//光源颜色
			// light.position.set(100, 100, 100);//光源位置
			// scene.add(light);//光源添加到场景中

			// light = new THREE.PointLight(0xffffff);
			// light.position.set(500, 500, 500);
			// light.castShadow = true;
			// scene.add(light);

			// const light = new THREE.HemisphereLight( 0xffffbb, 0x080820, 1 );
			// scene.add( light );

			//lights
			const width = 25;
			const height = 25;
			const intensity = 30;
			RectAreaLightUniformsLib.init();

			// let pointLight2 = new THREE.PointLight(0xffffff);
			// pointLight2.position.set(0, 50, 0);
			// scene.add(pointLight2);

			let pointLight = new THREE.RectAreaLight(
				0xffffff,
				intensity,
				width,
				height
			);
			pointLight.position.set(99, 5, 0);
			pointLight.lookAt(0, 5, 0);
			scene.add(pointLight);
			// const pointLightHelper = new RectAreaLightHelper(pointLight);
			// pointLight.add(pointLightHelper);

			const blueRectLight = new THREE.RectAreaLight(
				0xfdf4dc,
				intensity,
				width,
				height
			);
			blueRectLight.position.set(99, 5, 0);
			blueRectLight.lookAt(0, 5, 0);
			// scene.add(blueRectLight);

			// const blueRectLightHelper = new RectAreaLightHelper(blueRectLight);
			// blueRectLight.add(blueRectLightHelper);

			const redRectLight = new THREE.RectAreaLight(
				0xfdf4dc,
				intensity,
				width,
				height
			);
			redRectLight.position.set(-99, 5, 0);
			redRectLight.lookAt(0, 5, 0);
			scene.add(redRectLight);
		}

		function initTestModel(){
			//辅助工具 三角定位
			// var helper = new THREE.AxesHelper(100);
			// scene.add(helper);

			// cube camera for environment map
			const cubeRenderTarget = new THREE.WebGLCubeRenderTarget(512, {
					format: THREE.RGBFormat,
					generateMipmaps: true,
					minFilter: THREE.LinearMipmapLinearFilter,
			});
			cubeCamera = new THREE.CubeCamera(1, 1000, cubeRenderTarget);

			cubeCamera.position.set(0, 100, 0);
			scene.add(cubeCamera);

			// ground floor ( with box projected environment mapping )
			const loader = new THREE.TextureLoader();
			const rMap = loader.load("textures/lava/lavatile.jpg");
			rMap.wrapS = THREE.RepeatWrapping;
			rMap.wrapT = THREE.RepeatWrapping;
			rMap.repeat.set(2, 1);

			const defaultMat = new THREE.MeshPhysicalMaterial({
				roughness: 1,
				envMap: cubeRenderTarget.texture,
				roughnessMap: rMap,
			});

			const boxProjectedMat = new THREE.MeshPhysicalMaterial({
				color: new THREE.Color("#ffffff"),
				roughness: 1,
				envMap: cubeRenderTarget.texture,
				roughnessMap: rMap,
			});


			groundPlane = new THREE.Mesh(
				new THREE.PlaneGeometry(200, 100, 100),
				boxProjectedMat
			);
			groundPlane.rotateX(-Math.PI / 2);
			groundPlane.position.set(0, -49, 0);
			scene.add(groundPlane);

			// walls
			const paintingTex1 = loader.load("textures/scream.jpg", function () {
				updateCubeMap();
			});
			const paintingTex2 = loader.load("textures/starry-night.jpg",function () {
				updateCubeMap();
			});
			const diffuseTex = loader.load("textures/brick_diffuse.jpg",function () {
				updateCubeMap();
			});
			const bumpTex = loader.load("textures/brick_bump.jpg", function () {
				updateCubeMap();
			});

			// 第一幅畫
			wallMatPaintingMat1 = new THREE.MeshPhysicalMaterial({
				map: paintingTex1,
				// bumpMap: bumpTex,
				// bumpScale: 0.3,
				// side: THREE.DoubleSide,
			});
			// 第二幅畫
			wallMatPaintingMat2 = new THREE.MeshPhysicalMaterial({
				map: paintingTex2,
				// bumpMap: bumpTex,
				// bumpScale: 0.3,
				// side: THREE.DoubleSide,
			});

			wallMat = new THREE.MeshPhysicalMaterial({
				map: diffuseTex,
				bumpMap: bumpTex,
				bumpScale: 2,
				// side: THREE.DoubleSide,
			});

			// 第一幅畫面板寬高設定
			const paintingPanel1 = new THREE.PlaneGeometry(31.68, 40);
			// 第二幅畫面板寬高設定
			const paintingPanel2 = new THREE.PlaneGeometry(46.44, 35);

			//第一幅畫面板貼圖設定
			const plane1 = new THREE.Mesh(paintingPanel1, wallMatPaintingMat1);
			plane1.position.set(40, 0, -49);
			scene.add(plane1);
			objects.push(plane1);
			//第二幅畫面板貼圖設定
			const plane2 = new THREE.Mesh(paintingPanel2, wallMatPaintingMat2);
			plane2.position.set(-25, 0, -49);
			scene.add(plane2);
			objects.push(plane2);

			const planeGeo = new THREE.PlaneGeometry(100, 100); // 全部牆的寬高

			const planeBack1 = new THREE.Mesh(planeGeo, wallMat);
			planeBack1.position.z = -50;
			planeBack1.position.x = -50;
			// planeBack1.rotateY(Math.PI / 2);
			scene.add(planeBack1);
			objects.push(planeBack1);

			const planeBack2 = new THREE.Mesh(planeGeo, wallMat);
			planeBack2.position.set(50, 0, -50);
			// planeBack2.position.x = 50;
			scene.add(planeBack2);
			objects.push(planeBack2);

			const planeFront1 = new THREE.Mesh(planeGeo, wallMat);
			planeFront1.position.z = 50;
			planeFront1.position.x = -50;
			planeFront1.rotateY(Math.PI);
			scene.add(planeFront1);
			objects.push(planeFront1);

			const planeFront2 = new THREE.Mesh(planeGeo, wallMat);
			planeFront2.position.z = 50;
			planeFront2.position.x = 50;
			planeFront2.rotateY(Math.PI);
			scene.add(planeFront2);
			objects.push(planeFront2);

			const planeRight = new THREE.Mesh(planeGeo, wallMat);
			planeRight.position.x = 100;
			planeRight.rotateY(-Math.PI / 2);
			scene.add(planeRight);
			objects.push(planeRight);

			const planeLeft = new THREE.Mesh(planeGeo, wallMat);
			planeLeft.position.x = -100;
			planeLeft.rotateY(Math.PI / 2);
			scene.add(planeLeft);
			objects.push(planeLeft);
		}

		function initModel() {
			//辅助工具 三角定位
			var helper = new THREE.AxesHelper(100);
			scene.add(helper);

			//#region obj mtl loader
			//建立mtl檔案載入器
			// var mtlLoader = new MTLLoader();
			// //載入mtl檔案，mtl檔案中引用的圖片路徑需要改為相對路徑
			// mtlLoader.load('obj/台科建築畢業展覽.mtl', function(material) {
			// 	//建立obj檔案載入器
			// 	var objLoader = new OBJLoader();
			// 	//設定當前載入的紋理
			// 	objLoader.setMaterials(material);
			// 	//載入obj檔案
			// 	objLoader.load('obj/台科建築畢業展覽.obj', function(object) {
			// 		object.scale.set(0.2, 0.2, 0.2);
            //         object.traverse(function (child) {
            //             child.castShadow = true;
            //             child.receiveShadow = true;
            //             objects.push(child);
            //         }, {normalizeRGB: true});
			// 		scene.add(object);
			// 	});
			// });
			//#endregion

			//#region GLTF loader
			//建立GLTF檔案載入器
			// const loader = new GLTFLoader();
			// loader.load( 'path/to/model.glb', function ( gltf ) {
			// 	scene.add(gltf.scene);
			// }, undefined, function ( error ) {
			// 	console.error( error );
			// } );
			//#endregion
			
			//#region dae loader
			//建立dae檔案載入器
			// var loader = new ColladaLoader();
			// loader.load('dae/台科建築畢業展覽.dae', function (collada) {
			// 	const dae = collada.scene;
			// 	console.log("x:" + dae.position.x);
			// 	console.log("y:" + dae.position.y);
			// 	console.log("z:" + dae.position.z);
			// 	scene.add(collada.scene);
			// 	setModelPosition(dae)
			// });
			//#endregion
		}

		function updateCubeMap() {
			//disable specular highlights on walls in the environment map
			wallMat.roughness = 1;
			groundPlane.visible = false;

			// cubeCamera.position.copy(groundPlane.position);
			cubeCamera.update(renderer, scene);
			wallMat.roughness = 0.6;
			groundPlane.visible = true;

			render();
		}

		function setModelPosition(object) { 
			object.updateMatrixWorld();
			const box = new THREE.Box3().setFromObject(object);
			const boxSize = box.getSize();
			const center = box.getCenter(new THREE.Vector3());
			object.position.x += object.position.x - center.x;
			object.position.y += object.position.y - center.y; 
			object.position.z += object.position.z - center.z;
		}


		function initStats() {
			stats = new Stats();
			document.body.appendChild(stats.dom);
		}

		function initControls() {

			//#region  要用上帝視角用這個
			// controls = new OrbitControls(camera, renderer.domElement );
			// controls.enableDamping = true // 啟用阻尼效果
			// controls.dampingFactor = 0.25 // 阻尼系數
			// //相机与模型最小距离，模型看上去大
            // controls.minDistance = 1;
            // //相机与模型最大距离，模型看上去小
            // controls.maxDistance = 1000;
			//#endregion

			//#region 要走路用這個
			const blocker = document.getElementById('blocker');
			blocker.addEventListener('click', function () {
				controls.lock();
			}, false);

			controls = new PointerLockControls(camera);
			controls.addEventListener("lock", () => (blocker.style.display = "none"));
			controls.addEventListener("unlock", () => (blocker.style.display = "block"));
			scene.add(controls.getObject());
			raycaster = new THREE.Raycaster(
				new THREE.Vector3(),
				new THREE.Vector3(0, 0, 0),0,10
			);

			var onKeyDown = function (event) {
			switch (event.keyCode) {
				case 38: // up
				case 87: // w
				moveForward = true;
				break;
				case 37: // left
				case 65: // a
				moveLeft = true;
				break;
				case 40: // down
				case 83: // s
				moveBackward = true;
				break;
				case 39: // right
				case 68: // d
				moveRight = true;
				break;
			}
			};
			var onKeyUp = function (event) {
			switch (event.keyCode) {
				case 38: // up
				case 87: // w
				moveForward = false;
				break;
				case 37: // left
				case 65: // a
				moveLeft = false;
				break;
				case 40: // down
				case 83: // s
				moveBackward = false;
				break;
				case 39: // right
				case 68: // d
				moveRight = false;
				break;
			}
			};
			document.addEventListener("keydown", onKeyDown, false);
			document.addEventListener("keyup", onKeyUp, false);
			//#endregion
		}

		function render() {
			renderer.render(scene, camera);
		}

		function onWindowResize(){
    		camera.aspect = window.innerWidth / window.innerHeight;
    		camera.updateProjectionMatrix();
    		renderer.setSize(window.innerWidth, window.innerHeight);
		}

		function animate() {
			
			requestAnimationFrame(animate);
			//更新控制器
			render();

			
			var time = performance.now();
			var delta = ( time - prevTime ) / 1000;
			velocity.x -= velocity.x * 10.0 * delta;
			velocity.z -= velocity.z * 10.0 * delta;
			if ( moveForward ) velocity.z -= 300.0 * delta;
			if ( moveBackward ) velocity.z += 300.0 * delta;
			if ( moveLeft ) velocity.x -= 300.0 * delta;
			if ( moveRight ) velocity.x += 300.0 * delta;
			controls.getObject().translateX( velocity.x * delta );
			controls.getObject().translateZ( velocity.z * delta );
			controls.getObject().position.y = 0;
			prevTime = time;


			//更新性能插件
			stats.update();
			// controls.update();
		}

		function draw() {
			initRender();
			initScene();
			initCamera();
			initGUI();
			initLight();
			// initModel();
			initTestModel();
			initControls();
			initStats();
			animate();
			
			window.onresize = onWindowResize;
		}
	</script>
</body>

</html>